{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","incremental-dom.js","node_modules/browserify/node_modules/process/browser.js","src/alignment.js","src/attributes.js","src/namespace.js","src/node_data.js","src/nodes.js","src/patch.js","src/traversal.js","src/tree_walker.js","src/virtual_elements.js","src/walker.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","IncrementalDOM","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"patch","elements","attributes","elementVoid","elementOpenStart","elementOpenEnd","elementOpen","elementClose","text","attr","./src/attributes","./src/patch","./src/virtual_elements",2,"cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","setTimeout","len","run","clearTimeout","Item","fun","array","noop","process","nextTick","args","Array","arguments","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",3,"nodes","createNode","getChild","registerChild","nodeData","getKey","getNodeName","getWalker","matches","node","nodeName","key","alignWithDOM","statics","matchingNode","walker","currentNode","parent","getCurrentParent","existingNode","doc","insertBefore","./node_data","./nodes","./walker",4,"getData","applyAttr","el","value","type","undefined","removeAttribute","setAttribute","applyStyle","style","cssText","prop","updateAttribute","data","attrs",5,"SVG_NS","enterTag","tag","enterNamespace","exitTag","exitNamespace","getNamespaceForTag","getCurrentNamespace",6,"NodeData","attrsArr","newAttrs","keyMap","lastVisitedChild","initData","toLowerCase","Element","getAttribute",7,"createElement","namespace","createElementNS","createTextNode","createKeyMap","map","children","count","child","getKeyMap","./attributes","./namespace",8,"traversal","firstChild","parentNode","TreeWalker","setWalker","fn","prevWalker","./traversal","./tree_walker",9,"enterNode","exitNode","lastChild","removeChild","markVisited","nextSibling",10,"stack_","ownerDocument","nsStack_","pop",11,"ATTRIBUTES_OFFSET","argsBuilder","IS_PRODUCTION","NODE_ENV","inAttributes","assertNotInAttributes","assertInAttributes","setInAttributes","setNotInAttributes","hasChangedAttrs","unused1","unused2","unused3","var_args","attrsChanged","j","updateNewAttrs","updateAttributes","./alignment","_process",12,"walker_"],"mappings":"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","file":"incremental-dom.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar patch = require('./src/patch').patch;\nvar elements = require('./src/virtual_elements');\nvar attributes = require('./src/attributes');\n\nmodule.exports = {\n  patch: patch,\n  elementVoid: elements.elementVoid,\n  elementOpenStart: elements.elementOpenStart,\n  elementOpenEnd: elements.elementOpenEnd,\n  elementOpen: elements.elementOpen,\n  elementClose: elements.elementClose,\n  text: elements.text,\n  attr: elements.attr,\n  attributes: attributes\n};\n\n",null,"// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar nodes = require('./nodes'),\n    createNode = nodes.createNode,\n    getChild = nodes.getChild,\n    registerChild = nodes.registerChild;\nvar nodeData = require('./node_data'),\n    getKey = nodeData.getKey,\n    getNodeName = nodeData.getNodeName;\nvar getWalker = require('./walker').getWalker;\n\n\n/**\n * Checks whether or not a given node matches the specified nodeName and key.\n *\n * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function(node, nodeName, key) {\n  if (key) {\n    return key === getKey(node);\n  }\n  return nodeName === getNodeName(node);\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {?string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string} key The key used to identify this element.\n * @param {?Array<*>|string} statics For an Element, this should be an array of\n *     name-value pairs. For a Text, this should be the text content of the\n *     node.\n * @return {!Node} The matching node.\n */\nvar alignWithDOM = function(nodeName, key, statics) {\n  var walker = getWalker();\n  var currentNode = walker.currentNode;\n  var parent = walker.getCurrentParent();\n  var matchingNode;\n\n  // Check to see if we have a node to reuse\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    matchingNode = currentNode;\n  } else {\n    var existingNode = key && getChild(parent, key);\n\n    // Check to see if the node has moved within the parent or if a new one\n    // should be created\n    if (existingNode) {\n      matchingNode = existingNode;\n    } else {\n      matchingNode = createNode(walker.doc, nodeName, key, statics);\n      if (key) {\n        registerChild(parent, key, matchingNode);\n      }\n    }\n\n    parent.insertBefore(matchingNode, currentNode);\n    walker.currentNode = matchingNode;\n  }\n\n  return matchingNode;\n};\n\n\n/** */\nmodule.exports = {\n  alignWithDOM: alignWithDOM\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar getData = require('./node_data').getData;\n\n\nvar attributes = {\n  /**\n   * Applies an attribute or property to a given Element. If the value is a\n   * object or a function (which includes null), it is set as a property on the\n   * Element. Otherwise, the value is set as an attribute.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value. If the value is a string, it is set\n   *     as an HTML attribute, otherwise, it is set on node.\n   */\n  applyAttr: function(el, name, value) {\n    var type = typeof value;\n\n    if (type === 'object' || type === 'function') {\n      el[name] = value;\n    } else if (value === undefined) {\n      el.removeAttribute(name);\n    } else {\n      el.setAttribute(name, value);\n    }\n  },\n\n\n  /**\n   * Applies a style to an Element. No vendor prefix expansion is done for\n   * property names/values.\n   * @param {!Element} el\n   * @param {string|Object<string,string>} style The style to set. Either a\n   *     string of css or an object containing property-value pairs.\n   */\n  applyStyle: function(el, style) {\n    if (typeof style === 'string') {\n      el.style.cssText = style;\n    } else {\n      el.style.cssText = '';\n\n      for (var prop in style) {\n        el.style[prop] = style[prop];\n      }\n    }\n  },\n\n\n  /**\n   * Updates a single attribute on an Element.\n   * @param {!Element} el\n   * @param {string} name The attribute's name.\n   * @param {*} value The attribute's value. If the value is a string, it is set\n   *     as an HTML attribute, otherwise, it is set on node.\n   */\n  updateAttribute: function(el, name, value) {\n    var data = getData(el);\n    var attrs = data.attrs;\n\n    if (attrs[name] === value) {\n      return;\n    }\n\n    if (name === 'style') {\n      attributes.applyStyle(el, value);\n    } else {\n      attributes.applyAttr(el, name, value);\n    }\n\n    attrs[name] = value;\n  }\n};\n\n\n/** */\nmodule.exports = attributes;\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar getWalker = require('./walker').getWalker;\n\nvar SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Enters a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar enterTag = function(tag) {\n  if (tag === 'svg') {\n    getWalker().enterNamespace(SVG_NS);\n  } else if (tag === 'foreignObject') {\n    getWalker().enterNamespace(undefined);\n  }\n};\n\n\n/**\n * Exits a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar exitTag = function(tag) {\n  if (tag === 'svg' || tag === 'foreignObject') {\n    getWalker().exitNamespace();\n  }\n};\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @return {string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function(tag) {\n  if (tag === 'svg') {\n    return SVG_NS;\n  }\n\n  return getWalker().getCurrentNamespace();\n};\n\n\n/** */\nmodule.exports = {\n  enterTag: enterTag,\n  exitTag: exitTag,\n  getNamespaceForTag: getNamespaceForTag\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {?string} nodeName\n * @param {?string} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const\n   */\n  this.attrs = {};\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = {};\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key || null;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, Node>}\n   */\n  this.keyMap = null;\n\n  /**\n   * The last child to have been visited within the current pass.\n   * {?Node}\n   */\n  this.lastVisitedChild = null;\n\n  /**\n   * The node name for this node.\n   * @const\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @const {string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {!Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function(node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {!Node} node The node to retrieve the data for.\n * @return {NodeData} The NodeData for this Node.\n */\nvar getData = function(node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n\n/**\n * @param {?Node} node A node to get the key for.\n * @return {?string} The key for the Node, if applicable.\n */\nvar getKey = function(node) {\n  return getData(node).key;\n};\n\n\n/**\n * @param {?Node} node A node to get the node name for.\n * @return {?string} The node name for the Node, if applicable.\n */\nvar getNodeName = function(node) {\n  return getData(node).nodeName;\n};\n\n\n/** */\nmodule.exports = {\n  getData: getData,\n  initData: initData,\n  getKey: getKey,\n  getNodeName: getNodeName\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar updateAttribute = require('./attributes').updateAttribute;\nvar nodeData = require('./node_data'),\n    getData = nodeData.getData,\n    getKey = nodeData.getKey,\n    initData = nodeData.initData;\nvar getNamespaceForTag = require('./namespace').getNamespaceForTag;\n\n\n/**\n * Creates an Element.\n * @param {!Document} doc The document with which to create the Element.\n * @param {string} tag The tag for the Element.\n * @param {?string} key A key to identify the Element.\n * @param {?Array<*>} statics An array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function(doc, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text.\n * @param {!Document} doc The document with which to create the Text.\n * @param {string} text The initial content of the Text.\n * @return {!Text}\n */\nvar createTextNode = function(doc, text) {\n  var node = doc.createTextNode(text);\n  getData(node).text = text;\n\n  return node;\n};\n\n\n/**\n * Creates a Node, either a Text or an Element depending on the node name\n * provided.\n * @param {!Document} doc The document with which to create the Node.\n * @param {string} nodeName The tag if creating an element or #text to create\n *     a Text.\n * @param {?string} key A key to identify the Element.\n * @param {?Array<*>|string} statics The static data to initialize the Node\n *     with. For an Element, an array of attribute name/value pairs of\n *     the static attributes for the Element. For a Text, a string with the\n *     initial content of the Text.\n * @return {!Node}\n */\nvar createNode = function(doc, nodeName, key, statics) {\n  if (nodeName === '#text') {\n    return createTextNode(doc, statics);\n  }\n\n  return createElement(doc, nodeName, key, statics);\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {!Element} el\n * @return {!Object<string, !Node>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function(el) {\n  var map = {};\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getKey(child);\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {!Element} el\n * @return {!Object<string,!Node>} A mapping of keys to child Nodes\n */\nvar getKeyMap = function(el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {!Element} parent\n * @param {?string} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function(parent, key) {\n  return getKeyMap(parent)[key];\n};\n\n\n/**\n * Registers a node as being a child. The parent will keep track of the child\n * using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {!Element} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n\n/** */\nmodule.exports = {\n  createNode: createNode,\n  getChild: getChild,\n  registerChild: registerChild\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar traversal = require('./traversal'),\n    firstChild = traversal.firstChild,\n    parentNode = traversal.parentNode;\nvar TreeWalker = require('./tree_walker');\nvar walker = require('./walker'),\n    getWalker = walker.getWalker,\n    setWalker = walker.setWalker;\n\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!Document} node The Element or Document to patch.\n * @param {!function} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {*} data An argument passed to fn to represent DOM state.\n */\nvar patch = function(node, fn, data) {\n  var prevWalker = getWalker();\n  setWalker(new TreeWalker(node));\n\n  firstChild();\n  fn(data);\n  parentNode();\n\n  setWalker(prevWalker);\n};\n\n\n/** */\nmodule.exports = {\n  patch: patch\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar getWalker = require('./walker').getWalker;\nvar getData = require('./node_data').getData;\nvar namespace = require('./namespace');\n\n\n/**\n * Enters a Element, setting the current namespace for nested elements.\n * @param {!Element} node\n */\nvar enterNode = function(node) {\n  var data = getData(node);\n  namespace.enterTag(data.nodeName);\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them, and unwinds the current namespace\n * to the previous value.\n * @param {!Element} node\n */\nvar exitNode = function(node) {\n  var data = getData(node);\n  var lastVisitedChild = data.lastVisitedChild;\n  data.lastVisitedChild = null;\n\n  namespace.exitTag(data.nodeName);\n\n  if (node.lastChild === lastVisitedChild) {\n    return;\n  }\n\n  while (node.lastChild !== lastVisitedChild) {\n    node.removeChild(node.lastChild);\n  }\n\n  // Invalidate the key map since we removed children. It will get recreated\n  // next time we need it.\n  data.keyMap = null;\n};\n\n\n/**\n * Marks node's parent as having visited node.\n * @param {!Node} node\n */\nvar markVisited = function(node) {\n  var walker = getWalker();\n  var parent = walker.getCurrentParent();\n  var data = getData(parent);\n  data.lastVisitedChild = node;\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nvar firstChild = function() {\n  var walker = getWalker();\n  enterNode(walker.currentNode);\n  walker.firstChild();\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextSibling = function() {\n  var walker = getWalker();\n  markVisited(walker.currentNode);\n  walker.nextSibling();\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar parentNode = function() {\n  var walker = getWalker();\n  walker.parentNode();\n  exitNode(walker.currentNode);\n};\n\n\n/** */\nmodule.exports = {\n  firstChild: firstChild,\n  nextSibling: nextSibling,\n  parentNode: parentNode\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Similar to the built-in Treewalker class, but simplified and allows direct\n * access to modify the currentNode property.\n * @param {!Node} node The root Node of the subtree the walker should start\n *     traversing.\n * @constructor\n */\nfunction TreeWalker(node) {\n  /**\n   * Keeps track of the current parent node. This is necessary as the traversal\n   * methods may traverse past the last child and we still need a way to get\n   * back to the parent.\n   * @const @private {!Array<!Node>}\n   */\n  this.stack_ = [];\n\n  /** {?Node} */\n  this.currentNode = node;\n\n  /** {!Document} */\n  this.doc = node.ownerDocument;\n\n  /**\n   * Keeps track of what namespace to create new Elements in.\n   * @const @private {!Array<string>}\n   */\n  this.nsStack_ = [undefined];\n}\n\n\n/**\n * @return {!Node} The current parent of the current location in the subtree.\n */\nTreeWalker.prototype.getCurrentParent = function() {\n  return this.stack_[this.stack_.length - 1];\n};\n\n\n/**\n * @return {string} The current namespace to create Elements in.\n */\nTreeWalker.prototype.getCurrentNamespace = function() {\n  return this.nsStack_[this.nsStack_.length - 1];\n};\n\n\n/**\n * @param {string} namespace The namespace to enter.\n */\nTreeWalker.prototype.enterNamespace = function(namespace) {\n  this.nsStack_.push(namespace);\n};\n\n\n/**\n * Exits the current namespace\n */\nTreeWalker.prototype.exitNamespace = function() {\n  this.nsStack_.pop();\n};\n\n\n/**\n * Changes the current location the firstChild of the current location.\n */\nTreeWalker.prototype.firstChild = function() {\n  this.stack_.push(this.currentNode);\n  this.currentNode = this.currentNode.firstChild;\n};\n\n\n/**\n * Changes the current location the nextSibling of the current location.\n */\nTreeWalker.prototype.nextSibling = function() {\n  this.currentNode = this.currentNode.nextSibling;\n};\n\n\n/**\n * Changes the current location the parentNode of the current location.\n */\nTreeWalker.prototype.parentNode = function() {\n  this.currentNode = this.stack_.pop();\n};\n\n\n/** */\nmodule.exports = TreeWalker;\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar alignWithDOM = require('./alignment').alignWithDOM;\nvar updateAttribute = require('./attributes').updateAttribute;\nvar getData = require('./node_data').getData;\nvar getWalker = require('./walker').getWalker;\nvar traversal = require('./traversal'),\n    firstChild = traversal.firstChild,\n    nextSibling = traversal.nextSibling,\n    parentNode = traversal.parentNode;\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @type {Array<*>}\n * @const\n */\nvar argsBuilder = [];\n\n/**\n * Verify if the script are running in production.\n * @type {boolean}\n * @const\n */\nvar IS_PRODUCTION = process.env.NODE_ENV === 'production';\n\nif (!IS_PRODUCTION) {\n  /**\n   * Keeps track whether or not we are in an attributes declaration (after\n   * elementOpenStart, but before elementOpenEnd).\n   * @type {boolean}\n   */\n  var inAttributes = false;\n\n\n  /** Makes sure that the caller is not where attributes are expected. */\n  var assertNotInAttributes = function() {\n    if (inAttributes) {\n      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' +\n          'they must follow a call to elementOpenStart.');\n    }\n  };\n\n\n  /** Makes sure that the caller is where attributes are expected. */\n  var assertInAttributes = function() {\n    if (!inAttributes) {\n      throw new Error('Was expecting a call to attr or elementOpenEnd. ' +\n          'elementOpenStart must be followed by zero or more calls to attr, ' +\n          'then one call to elementOpenEnd.');\n    }\n  };\n\n\n  /** Updates the state to being in an attribute declaration. */\n  var setInAttributes = function() {\n    inAttributes = true;\n  };\n\n\n  /** Updates the state to not being in an attribute declaration. */\n  var setNotInAttributes = function() {\n    inAttributes = false;\n  };\n}\n\n\n/**\n * Checks to see if one or more attributes have changed for a given\n * Element. When no attributes have changed, this function is much faster than\n * checking each individual argument. When attributes have changed, the overhead\n * of this function is minimal.\n *\n * This function is called in the context of the Element and the arguments from\n * elementOpen-like function so that the arguments are not de-optimized.\n *\n * @this {Element} The Element to check for changed attributes.\n * @param {*} unused1\n * @param {*} unused2\n * @param {*} unused3\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {boolean} True if the Element has one or more changed attributes,\n *     false otherwise.\n */\nvar hasChangedAttrs = function(unused1, unused2, unused3, var_args) {\n  var data = getData(this);\n  var attrsArr = data.attrsArr;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  return attrsChanged;\n};\n\n\n/**\n * Updates the newAttrs object for an Element.\n *\n * This function is called in the context of the Element and the arguments from\n * elementOpen-like function so that the arguments are not de-optimized.\n *\n * @this {Element} The Element to update newAttrs for.\n * @param {*} unused1\n * @param {*} unused2\n * @param {*} unused3\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Object<string, *>} The updated newAttrs object.\n */\nvar updateNewAttrs = function(unused1, unused2, unused3, var_args) {\n  var node = this;\n  var data = getData(node);\n  var newAttrs = data.newAttrs;\n\n  for (var attr in newAttrs) {\n    newAttrs[attr] = undefined;\n  }\n\n  for (var i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n    newAttrs[arguments[i]] = arguments[i + 1];\n  }\n\n  return newAttrs;\n};\n\n\n/**\n * Updates the attributes for a given Element.\n * @param {!Element} node\n * @param {!Object<string,*>} newAttrs The new attributes for node.\n */\nvar updateAttributes = function(node, newAttrs) {\n  for (var attr in newAttrs) {\n    updateAttribute(node, attr, newAttrs[attr]);\n  }\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required.\n * @param {string} tag The element's tag.\n * @param {?string} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function(tag, key, statics, var_args) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n  }\n\n  var node = alignWithDOM(tag, key, statics);\n\n  if (hasChangedAttrs.apply(node, arguments)) {\n    var newAttrs = updateNewAttrs.apply(node, arguments);\n    updateAttributes(node, newAttrs);\n  }\n\n  firstChild();\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function(tag, key, statics) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n    setInAttributes();\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function(name, value) {\n  if (!IS_PRODUCTION) {\n    assertInAttributes();\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function() {\n  if (!IS_PRODUCTION) {\n    assertInAttributes();\n    setNotInAttributes();\n  }\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n */\nvar elementClose = function(tag) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n  }\n\n  parentNode();\n  nextSibling();\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function(tag, key, statics, var_args) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n  }\n\n  var node = elementOpen.apply(null, arguments);\n  elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string} value The text of the Text.\n */\nvar text = function(value) {\n  if (!IS_PRODUCTION) {\n    assertNotInAttributes();\n  }\n\n  var node = alignWithDOM('#text', null, value);\n  var data = getData(node);\n\n  if (data.text !== value) {\n    node.data = value;\n    data.text = value;\n  }\n\n  nextSibling();\n};\n\n\n/** */\nmodule.exports = {\n  elementOpenStart: elementOpenStart,\n  elementOpenEnd: elementOpenEnd,\n  elementOpen: elementOpen,\n  elementVoid: elementVoid,\n  elementClose: elementClose,\n  text: text,\n  attr: attr\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @type {TreeWalker}\n */\nvar walker_;\n\n\n/**\n * @return {TreeWalker} the current TreeWalker\n */\nvar getWalker = function() {\n  return walker_;\n};\n\n\n/**\n * Sets the current TreeWalker\n * @param {TreeWalker} walker\n */\nvar setWalker = function(walker) {\n  walker_ = walker;\n};\n\n\n/** */\nmodule.exports = {\n  getWalker: getWalker,\n  setWalker: setWalker\n};\n\n"],"sourceRoot":"/source/"}